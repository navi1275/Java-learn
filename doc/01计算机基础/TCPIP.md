# 1.三次握手（three-way handshake）

刚开始，客户端处于**closed状态**，服务端处于**listener状态**

第一次握手：客户端发送一个**SYN**段报文，指明客户端打算连接的服务器端口以及初始序号**ISN（c）**。此时客户端处于**SYN_SENT**状态。

第二次握手：服务器收到客户端的SYN报文后，服务器会发回包含服务器的初始序号**ISN（s）**的SYN报文段作为应答，同时，将**确认序号ACK**设置为客户端的ISN（c）+1以对客户端的SYN报文段进行确认，表示已经收到了客户端的SYN报文。此时服务器处于**SYN_REVD**状态

第三次握手：客户端收到服务端的SYN报文后，会发送一个ACK报文，将**确认序号ACK**设置为服务器的ISN（c）+1，表示已经收到了服务端的SYN报文。此时客户端处于**established**状态

服务器收到ACK报文之后也处于**established**状态，此时双方建立起了链接，三次握手完成

![img](assets\16a074b331fb0d85.jpg)

## 作用

1. 确认双方的接收能力，发送能力是否正常
2. 指定自己的初始序号，为后面的可靠传输做准备

# 2.四次挥手

刚开始双方都处于**established**状态，一方发起关闭请求（假设是客户端）,

1.第一次挥手：客户端发送一个**FIN**报文给服务器，报文会指定一个序列号。此时客户端处于**FIN_WAIT_1**状态

2.第二次挥手：服务端接收到FIN报文之后，会发送**ACK**报文给客户端，且把客户端的传过来的序列号值+1作为ACK报文的序列号值，表明已经接收到客户端的报文了，此时服务器处于**CLOSE_WAIT**状态，客户端收到ACK报文后处于**FIN_WAIT_2**状态

3.第三次挥手：如果服务端也想断开连接，就和客户端第一次挥手一样，给客户端发送FIN报文，且指定一个序列号。此时服务器处于**LAST_ACK**的状态

4.第四次挥手：客户端收到FIN报文之后，一样会发送一个ACK报文作为应答且把服务器传过来的序列号值+1作为ACK报文的序列号值，此时客户端处于**TIME_WAIT**状态，需要过一阵子以确保服务端收到自己的ACK报文之后，才会进入**CLOSED**状态

5.服务端收到ACK报文之后，就关闭连接，处于**CLOSED**状态

![img](assets\16a074b855ad3850.jpg)



**TIME_WAIT状态**，为什么客户端发送ACK报文之后不直接关闭，而是要等一阵子才关闭？原因就是客户端要确保服务器已经接收到ACK报文了。如果没有接收到的话，服务器会重新发送FIN报文给客户端，客户端再次收到FIN报文，就知道之前的ACK报文丢失了，然后再次发送ACK报文。TIME_WAIT持续的使劲至少是一个报文来回的时间，设置一个计时，如果过了这个计时（RTT Round Trip Time 连接往返时间）都没有再次受到FIN报文，则代表服务器接收到了ACK报文，此时处于CLOSED状态

![img](assets\169c39cc18e7592a.jpg)

